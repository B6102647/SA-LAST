// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/B6102647/app/ent/book"
	"github.com/B6102647/app/ent/bookborrow"
	"github.com/B6102647/app/ent/purpose"
	"github.com/B6102647/app/ent/role"
	"github.com/B6102647/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBook       = "Book"
	TypeBookBorrow = "BookBorrow"
	TypePurpose    = "Purpose"
	TypeRole       = "Role"
	TypeUser       = "User"
)

// BookMutation represents an operation that mutate the Books
// nodes in the graph.
type BookMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_BOOK_NAME       *string
	_Author          *string
	clearedFields    map[string]struct{}
	_Booklist        map[int]struct{}
	removed_Booklist map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Book, error)
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows to manage the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for $n.Name.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the id field of the mutation.
func withBookID(id int) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBOOKNAME sets the BOOK_NAME field.
func (m *BookMutation) SetBOOKNAME(s string) {
	m._BOOK_NAME = &s
}

// BOOKNAME returns the BOOK_NAME value in the mutation.
func (m *BookMutation) BOOKNAME() (r string, exists bool) {
	v := m._BOOK_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldBOOKNAME returns the old BOOK_NAME value of the Book.
// If the Book object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookMutation) OldBOOKNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBOOKNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBOOKNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBOOKNAME: %w", err)
	}
	return oldValue.BOOKNAME, nil
}

// ResetBOOKNAME reset all changes of the "BOOK_NAME" field.
func (m *BookMutation) ResetBOOKNAME() {
	m._BOOK_NAME = nil
}

// SetAuthor sets the Author field.
func (m *BookMutation) SetAuthor(s string) {
	m._Author = &s
}

// Author returns the Author value in the mutation.
func (m *BookMutation) Author() (r string, exists bool) {
	v := m._Author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old Author value of the Book.
// If the Book object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor reset all changes of the "Author" field.
func (m *BookMutation) ResetAuthor() {
	m._Author = nil
}

// AddBooklistIDs adds the Booklist edge to BookBorrow by ids.
func (m *BookMutation) AddBooklistIDs(ids ...int) {
	if m._Booklist == nil {
		m._Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m._Booklist[ids[i]] = struct{}{}
	}
}

// RemoveBooklistIDs removes the Booklist edge to BookBorrow by ids.
func (m *BookMutation) RemoveBooklistIDs(ids ...int) {
	if m.removed_Booklist == nil {
		m.removed_Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Booklist[ids[i]] = struct{}{}
	}
}

// RemovedBooklist returns the removed ids of Booklist.
func (m *BookMutation) RemovedBooklistIDs() (ids []int) {
	for id := range m.removed_Booklist {
		ids = append(ids, id)
	}
	return
}

// BooklistIDs returns the Booklist ids in the mutation.
func (m *BookMutation) BooklistIDs() (ids []int) {
	for id := range m._Booklist {
		ids = append(ids, id)
	}
	return
}

// ResetBooklist reset all changes of the "Booklist" edge.
func (m *BookMutation) ResetBooklist() {
	m._Booklist = nil
	m.removed_Booklist = nil
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._BOOK_NAME != nil {
		fields = append(fields, book.FieldBOOKNAME)
	}
	if m._Author != nil {
		fields = append(fields, book.FieldAuthor)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldBOOKNAME:
		return m.BOOKNAME()
	case book.FieldAuthor:
		return m.Author()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldBOOKNAME:
		return m.OldBOOKNAME(ctx)
	case book.FieldAuthor:
		return m.OldAuthor(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldBOOKNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBOOKNAME(v)
		return nil
	case book.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldBOOKNAME:
		m.ResetBOOKNAME()
		return nil
	case book.FieldAuthor:
		m.ResetAuthor()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Booklist != nil {
		edges = append(edges, book.EdgeBooklist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m._Booklist))
		for id := range m._Booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Booklist != nil {
		edges = append(edges, book.EdgeBooklist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m.removed_Booklist))
		for id := range m.removed_Booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgeBooklist:
		m.ResetBooklist()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookBorrowMutation represents an operation that mutate the BookBorrows
// nodes in the graph.
type BookBorrowMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_ADDED_TIME     *time.Time
	clearedFields   map[string]struct{}
	_Owner          *int
	cleared_Owner   bool
	_BOOK           *int
	cleared_BOOK    bool
	_PURPOSE        *int
	cleared_PURPOSE bool
	done            bool
	oldValue        func(context.Context) (*BookBorrow, error)
}

var _ ent.Mutation = (*BookBorrowMutation)(nil)

// bookborrowOption allows to manage the mutation configuration using functional options.
type bookborrowOption func(*BookBorrowMutation)

// newBookBorrowMutation creates new mutation for $n.Name.
func newBookBorrowMutation(c config, op Op, opts ...bookborrowOption) *BookBorrowMutation {
	m := &BookBorrowMutation{
		config:        c,
		op:            op,
		typ:           TypeBookBorrow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookBorrowID sets the id field of the mutation.
func withBookBorrowID(id int) bookborrowOption {
	return func(m *BookBorrowMutation) {
		var (
			err   error
			once  sync.Once
			value *BookBorrow
		)
		m.oldValue = func(ctx context.Context) (*BookBorrow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookBorrow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookBorrow sets the old BookBorrow of the mutation.
func withBookBorrow(node *BookBorrow) bookborrowOption {
	return func(m *BookBorrowMutation) {
		m.oldValue = func(context.Context) (*BookBorrow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookBorrowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookBorrowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BookBorrowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetADDEDTIME sets the ADDED_TIME field.
func (m *BookBorrowMutation) SetADDEDTIME(t time.Time) {
	m._ADDED_TIME = &t
}

// ADDEDTIME returns the ADDED_TIME value in the mutation.
func (m *BookBorrowMutation) ADDEDTIME() (r time.Time, exists bool) {
	v := m._ADDED_TIME
	if v == nil {
		return
	}
	return *v, true
}

// OldADDEDTIME returns the old ADDED_TIME value of the BookBorrow.
// If the BookBorrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BookBorrowMutation) OldADDEDTIME(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldADDEDTIME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldADDEDTIME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldADDEDTIME: %w", err)
	}
	return oldValue.ADDEDTIME, nil
}

// ResetADDEDTIME reset all changes of the "ADDED_TIME" field.
func (m *BookBorrowMutation) ResetADDEDTIME() {
	m._ADDED_TIME = nil
}

// SetOwnerID sets the Owner edge to User by id.
func (m *BookBorrowMutation) SetOwnerID(id int) {
	m._Owner = &id
}

// ClearOwner clears the Owner edge to User.
func (m *BookBorrowMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared returns if the edge Owner was cleared.
func (m *BookBorrowMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the Owner id in the mutation.
func (m *BookBorrowMutation) OwnerID() (id int, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the Owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BookBorrowMutation) OwnerIDs() (ids []int) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "Owner" edge.
func (m *BookBorrowMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// SetBOOKID sets the BOOK edge to Book by id.
func (m *BookBorrowMutation) SetBOOKID(id int) {
	m._BOOK = &id
}

// ClearBOOK clears the BOOK edge to Book.
func (m *BookBorrowMutation) ClearBOOK() {
	m.cleared_BOOK = true
}

// BOOKCleared returns if the edge BOOK was cleared.
func (m *BookBorrowMutation) BOOKCleared() bool {
	return m.cleared_BOOK
}

// BOOKID returns the BOOK id in the mutation.
func (m *BookBorrowMutation) BOOKID() (id int, exists bool) {
	if m._BOOK != nil {
		return *m._BOOK, true
	}
	return
}

// BOOKIDs returns the BOOK ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BOOKID instead. It exists only for internal usage by the builders.
func (m *BookBorrowMutation) BOOKIDs() (ids []int) {
	if id := m._BOOK; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBOOK reset all changes of the "BOOK" edge.
func (m *BookBorrowMutation) ResetBOOK() {
	m._BOOK = nil
	m.cleared_BOOK = false
}

// SetPURPOSEID sets the PURPOSE edge to Purpose by id.
func (m *BookBorrowMutation) SetPURPOSEID(id int) {
	m._PURPOSE = &id
}

// ClearPURPOSE clears the PURPOSE edge to Purpose.
func (m *BookBorrowMutation) ClearPURPOSE() {
	m.cleared_PURPOSE = true
}

// PURPOSECleared returns if the edge PURPOSE was cleared.
func (m *BookBorrowMutation) PURPOSECleared() bool {
	return m.cleared_PURPOSE
}

// PURPOSEID returns the PURPOSE id in the mutation.
func (m *BookBorrowMutation) PURPOSEID() (id int, exists bool) {
	if m._PURPOSE != nil {
		return *m._PURPOSE, true
	}
	return
}

// PURPOSEIDs returns the PURPOSE ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PURPOSEID instead. It exists only for internal usage by the builders.
func (m *BookBorrowMutation) PURPOSEIDs() (ids []int) {
	if id := m._PURPOSE; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPURPOSE reset all changes of the "PURPOSE" edge.
func (m *BookBorrowMutation) ResetPURPOSE() {
	m._PURPOSE = nil
	m.cleared_PURPOSE = false
}

// Op returns the operation name.
func (m *BookBorrowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BookBorrow).
func (m *BookBorrowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BookBorrowMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ADDED_TIME != nil {
		fields = append(fields, bookborrow.FieldADDEDTIME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BookBorrowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookborrow.FieldADDEDTIME:
		return m.ADDEDTIME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BookBorrowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookborrow.FieldADDEDTIME:
		return m.OldADDEDTIME(ctx)
	}
	return nil, fmt.Errorf("unknown BookBorrow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookBorrowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookborrow.FieldADDEDTIME:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetADDEDTIME(v)
		return nil
	}
	return fmt.Errorf("unknown BookBorrow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BookBorrowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BookBorrowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BookBorrowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BookBorrow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BookBorrowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BookBorrowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookBorrowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookBorrow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BookBorrowMutation) ResetField(name string) error {
	switch name {
	case bookborrow.FieldADDEDTIME:
		m.ResetADDEDTIME()
		return nil
	}
	return fmt.Errorf("unknown BookBorrow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BookBorrowMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Owner != nil {
		edges = append(edges, bookborrow.EdgeOwner)
	}
	if m._BOOK != nil {
		edges = append(edges, bookborrow.EdgeBOOK)
	}
	if m._PURPOSE != nil {
		edges = append(edges, bookborrow.EdgePURPOSE)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BookBorrowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookborrow.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	case bookborrow.EdgeBOOK:
		if id := m._BOOK; id != nil {
			return []ent.Value{*id}
		}
	case bookborrow.EdgePURPOSE:
		if id := m._PURPOSE; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BookBorrowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BookBorrowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BookBorrowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Owner {
		edges = append(edges, bookborrow.EdgeOwner)
	}
	if m.cleared_BOOK {
		edges = append(edges, bookborrow.EdgeBOOK)
	}
	if m.cleared_PURPOSE {
		edges = append(edges, bookborrow.EdgePURPOSE)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BookBorrowMutation) EdgeCleared(name string) bool {
	switch name {
	case bookborrow.EdgeOwner:
		return m.cleared_Owner
	case bookborrow.EdgeBOOK:
		return m.cleared_BOOK
	case bookborrow.EdgePURPOSE:
		return m.cleared_PURPOSE
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BookBorrowMutation) ClearEdge(name string) error {
	switch name {
	case bookborrow.EdgeOwner:
		m.ClearOwner()
		return nil
	case bookborrow.EdgeBOOK:
		m.ClearBOOK()
		return nil
	case bookborrow.EdgePURPOSE:
		m.ClearPURPOSE()
		return nil
	}
	return fmt.Errorf("unknown BookBorrow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BookBorrowMutation) ResetEdge(name string) error {
	switch name {
	case bookborrow.EdgeOwner:
		m.ResetOwner()
		return nil
	case bookborrow.EdgeBOOK:
		m.ResetBOOK()
		return nil
	case bookborrow.EdgePURPOSE:
		m.ResetPURPOSE()
		return nil
	}
	return fmt.Errorf("unknown BookBorrow edge %s", name)
}

// PurposeMutation represents an operation that mutate the Purposes
// nodes in the graph.
type PurposeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_PURPOSE_NAME    *string
	clearedFields    map[string]struct{}
	_Booklist        map[int]struct{}
	removed_Booklist map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Purpose, error)
}

var _ ent.Mutation = (*PurposeMutation)(nil)

// purposeOption allows to manage the mutation configuration using functional options.
type purposeOption func(*PurposeMutation)

// newPurposeMutation creates new mutation for $n.Name.
func newPurposeMutation(c config, op Op, opts ...purposeOption) *PurposeMutation {
	m := &PurposeMutation{
		config:        c,
		op:            op,
		typ:           TypePurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPurposeID sets the id field of the mutation.
func withPurposeID(id int) purposeOption {
	return func(m *PurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *Purpose
		)
		m.oldValue = func(ctx context.Context) (*Purpose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Purpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPurpose sets the old Purpose of the mutation.
func withPurpose(node *Purpose) purposeOption {
	return func(m *PurposeMutation) {
		m.oldValue = func(context.Context) (*Purpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPURPOSENAME sets the PURPOSE_NAME field.
func (m *PurposeMutation) SetPURPOSENAME(s string) {
	m._PURPOSE_NAME = &s
}

// PURPOSENAME returns the PURPOSE_NAME value in the mutation.
func (m *PurposeMutation) PURPOSENAME() (r string, exists bool) {
	v := m._PURPOSE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldPURPOSENAME returns the old PURPOSE_NAME value of the Purpose.
// If the Purpose object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PurposeMutation) OldPURPOSENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPURPOSENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPURPOSENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPURPOSENAME: %w", err)
	}
	return oldValue.PURPOSENAME, nil
}

// ResetPURPOSENAME reset all changes of the "PURPOSE_NAME" field.
func (m *PurposeMutation) ResetPURPOSENAME() {
	m._PURPOSE_NAME = nil
}

// AddBooklistIDs adds the Booklist edge to BookBorrow by ids.
func (m *PurposeMutation) AddBooklistIDs(ids ...int) {
	if m._Booklist == nil {
		m._Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m._Booklist[ids[i]] = struct{}{}
	}
}

// RemoveBooklistIDs removes the Booklist edge to BookBorrow by ids.
func (m *PurposeMutation) RemoveBooklistIDs(ids ...int) {
	if m.removed_Booklist == nil {
		m.removed_Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Booklist[ids[i]] = struct{}{}
	}
}

// RemovedBooklist returns the removed ids of Booklist.
func (m *PurposeMutation) RemovedBooklistIDs() (ids []int) {
	for id := range m.removed_Booklist {
		ids = append(ids, id)
	}
	return
}

// BooklistIDs returns the Booklist ids in the mutation.
func (m *PurposeMutation) BooklistIDs() (ids []int) {
	for id := range m._Booklist {
		ids = append(ids, id)
	}
	return
}

// ResetBooklist reset all changes of the "Booklist" edge.
func (m *PurposeMutation) ResetBooklist() {
	m._Booklist = nil
	m.removed_Booklist = nil
}

// Op returns the operation name.
func (m *PurposeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Purpose).
func (m *PurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PurposeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._PURPOSE_NAME != nil {
		fields = append(fields, purpose.FieldPURPOSENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case purpose.FieldPURPOSENAME:
		return m.PURPOSENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case purpose.FieldPURPOSENAME:
		return m.OldPURPOSENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Purpose field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case purpose.FieldPURPOSENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPURPOSENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PurposeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PurposeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Purpose nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PurposeMutation) ResetField(name string) error {
	switch name {
	case purpose.FieldPURPOSENAME:
		m.ResetPURPOSENAME()
		return nil
	}
	return fmt.Errorf("unknown Purpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Booklist != nil {
		edges = append(edges, purpose.EdgeBooklist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m._Booklist))
		for id := range m._Booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Booklist != nil {
		edges = append(edges, purpose.EdgeBooklist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case purpose.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m.removed_Booklist))
		for id := range m.removed_Booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PurposeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Purpose unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PurposeMutation) ResetEdge(name string) error {
	switch name {
	case purpose.EdgeBooklist:
		m.ResetBooklist()
		return nil
	}
	return fmt.Errorf("unknown Purpose edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_ROLE_NAME    *string
	clearedFields map[string]struct{}
	role          map[int]struct{}
	removedrole   map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetROLENAME sets the ROLE_NAME field.
func (m *RoleMutation) SetROLENAME(s string) {
	m._ROLE_NAME = &s
}

// ROLENAME returns the ROLE_NAME value in the mutation.
func (m *RoleMutation) ROLENAME() (r string, exists bool) {
	v := m._ROLE_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldROLENAME returns the old ROLE_NAME value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldROLENAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldROLENAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldROLENAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldROLENAME: %w", err)
	}
	return oldValue.ROLENAME, nil
}

// ResetROLENAME reset all changes of the "ROLE_NAME" field.
func (m *RoleMutation) ResetROLENAME() {
	m._ROLE_NAME = nil
}

// AddRoleIDs adds the role edge to User by ids.
func (m *RoleMutation) AddRoleIDs(ids ...int) {
	if m.role == nil {
		m.role = make(map[int]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// RemoveRoleIDs removes the role edge to User by ids.
func (m *RoleMutation) RemoveRoleIDs(ids ...int) {
	if m.removedrole == nil {
		m.removedrole = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed ids of role.
func (m *RoleMutation) RemovedRoleIDs() (ids []int) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the role ids in the mutation.
func (m *RoleMutation) RoleIDs() (ids []int) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole reset all changes of the "role" edge.
func (m *RoleMutation) ResetRole() {
	m.role = nil
	m.removedrole = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._ROLE_NAME != nil {
		fields = append(fields, role.FieldROLENAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldROLENAME:
		return m.ROLENAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldROLENAME:
		return m.OldROLENAME(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldROLENAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetROLENAME(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldROLENAME:
		m.ResetROLENAME()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrole != nil {
		edges = append(edges, role.EdgeRole)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_USER_EMAIL      *string
	_USER_NAME       *string
	clearedFields    map[string]struct{}
	_Booklist        map[int]struct{}
	removed_Booklist map[int]struct{}
	_RolePlay        *int
	cleared_RolePlay bool
	done             bool
	oldValue         func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUSEREMAIL sets the USER_EMAIL field.
func (m *UserMutation) SetUSEREMAIL(s string) {
	m._USER_EMAIL = &s
}

// USEREMAIL returns the USER_EMAIL value in the mutation.
func (m *UserMutation) USEREMAIL() (r string, exists bool) {
	v := m._USER_EMAIL
	if v == nil {
		return
	}
	return *v, true
}

// OldUSEREMAIL returns the old USER_EMAIL value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSEREMAIL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSEREMAIL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSEREMAIL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSEREMAIL: %w", err)
	}
	return oldValue.USEREMAIL, nil
}

// ResetUSEREMAIL reset all changes of the "USER_EMAIL" field.
func (m *UserMutation) ResetUSEREMAIL() {
	m._USER_EMAIL = nil
}

// SetUSERNAME sets the USER_NAME field.
func (m *UserMutation) SetUSERNAME(s string) {
	m._USER_NAME = &s
}

// USERNAME returns the USER_NAME value in the mutation.
func (m *UserMutation) USERNAME() (r string, exists bool) {
	v := m._USER_NAME
	if v == nil {
		return
	}
	return *v, true
}

// OldUSERNAME returns the old USER_NAME value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUSERNAME(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUSERNAME is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUSERNAME requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUSERNAME: %w", err)
	}
	return oldValue.USERNAME, nil
}

// ResetUSERNAME reset all changes of the "USER_NAME" field.
func (m *UserMutation) ResetUSERNAME() {
	m._USER_NAME = nil
}

// AddBooklistIDs adds the Booklist edge to BookBorrow by ids.
func (m *UserMutation) AddBooklistIDs(ids ...int) {
	if m._Booklist == nil {
		m._Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m._Booklist[ids[i]] = struct{}{}
	}
}

// RemoveBooklistIDs removes the Booklist edge to BookBorrow by ids.
func (m *UserMutation) RemoveBooklistIDs(ids ...int) {
	if m.removed_Booklist == nil {
		m.removed_Booklist = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Booklist[ids[i]] = struct{}{}
	}
}

// RemovedBooklist returns the removed ids of Booklist.
func (m *UserMutation) RemovedBooklistIDs() (ids []int) {
	for id := range m.removed_Booklist {
		ids = append(ids, id)
	}
	return
}

// BooklistIDs returns the Booklist ids in the mutation.
func (m *UserMutation) BooklistIDs() (ids []int) {
	for id := range m._Booklist {
		ids = append(ids, id)
	}
	return
}

// ResetBooklist reset all changes of the "Booklist" edge.
func (m *UserMutation) ResetBooklist() {
	m._Booklist = nil
	m.removed_Booklist = nil
}

// SetRolePlayID sets the RolePlay edge to Role by id.
func (m *UserMutation) SetRolePlayID(id int) {
	m._RolePlay = &id
}

// ClearRolePlay clears the RolePlay edge to Role.
func (m *UserMutation) ClearRolePlay() {
	m.cleared_RolePlay = true
}

// RolePlayCleared returns if the edge RolePlay was cleared.
func (m *UserMutation) RolePlayCleared() bool {
	return m.cleared_RolePlay
}

// RolePlayID returns the RolePlay id in the mutation.
func (m *UserMutation) RolePlayID() (id int, exists bool) {
	if m._RolePlay != nil {
		return *m._RolePlay, true
	}
	return
}

// RolePlayIDs returns the RolePlay ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RolePlayID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RolePlayIDs() (ids []int) {
	if id := m._RolePlay; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRolePlay reset all changes of the "RolePlay" edge.
func (m *UserMutation) ResetRolePlay() {
	m._RolePlay = nil
	m.cleared_RolePlay = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._USER_EMAIL != nil {
		fields = append(fields, user.FieldUSEREMAIL)
	}
	if m._USER_NAME != nil {
		fields = append(fields, user.FieldUSERNAME)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.USEREMAIL()
	case user.FieldUSERNAME:
		return m.USERNAME()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUSEREMAIL:
		return m.OldUSEREMAIL(ctx)
	case user.FieldUSERNAME:
		return m.OldUSERNAME(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUSEREMAIL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSEREMAIL(v)
		return nil
	case user.FieldUSERNAME:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUSERNAME(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUSEREMAIL:
		m.ResetUSEREMAIL()
		return nil
	case user.FieldUSERNAME:
		m.ResetUSERNAME()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Booklist != nil {
		edges = append(edges, user.EdgeBooklist)
	}
	if m._RolePlay != nil {
		edges = append(edges, user.EdgeRolePlay)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m._Booklist))
		for id := range m._Booklist {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRolePlay:
		if id := m._RolePlay; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Booklist != nil {
		edges = append(edges, user.EdgeBooklist)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooklist:
		ids := make([]ent.Value, 0, len(m.removed_Booklist))
		for id := range m.removed_Booklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_RolePlay {
		edges = append(edges, user.EdgeRolePlay)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRolePlay:
		return m.cleared_RolePlay
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRolePlay:
		m.ClearRolePlay()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBooklist:
		m.ResetBooklist()
		return nil
	case user.EdgeRolePlay:
		m.ResetRolePlay()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
